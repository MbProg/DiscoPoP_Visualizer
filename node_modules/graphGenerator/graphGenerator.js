var d3 = require('d3');
var dagreD3 = require('dagre-d3');
var ipc = require("electron").ipcMain;
var xml2js = require('xml2js');
var fs = require('fs');

function buildGraphFromXML(filepath) {
  //Parse xml
  var parser = xml2js.Parser();
  var xml = fs.readFileSync(filepath);
  var data;
  parser.parseString(xml, function(err, result) {
    data = result;
  });
  console.log(JSON.stringify(data.RegionVars.Region[0]));

  // Build graph
  g = new dagreD3.graphlib.Graph({
      compound: true
    })
    .setGraph({})
    .setDefaultEdgeLabel(function() {
      return {};
    });

  // Add nodes (CUs)
  data.RegionVars.Region.forEach(function(v) {
    g.setNode(v.id, {
      label: v.id
    });
  });

  // Add edges (dependencies)
  data.RegionVars.Region.forEach(function(v) {
    g.setEdge(v.id, 'b');
    g.setNode(v.id, {
      label: v.id
    });
  });
}

function renderGraph() {
  alert('rendering');
  loadTestGraph();
  var render = new dagreD3.render();
  // Set up an SVG group so that we can translate the final graph.
  var svg = d3.select("svg"),
    svgGroup = svg.append("g");

  // Run the renderer. This is what draws the final graph.
  render(d3.select("svg g"), g);

  // Center the graph
  var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
  svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
  svg.attr("height", g.graph().height + 40);
}

module.exports = {
  buildGraphFromXML: buildGraphFromXML
};
